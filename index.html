<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Open-Source Map Solution</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 0;
            min-height: 700px;
        }
        
        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
        }
        
        .form-group {
            margin-bottom: 25px;
            position: relative;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.95rem;
        }
        
        .input-container {
            position: relative;
        }
        
        input[type="text"], input[type="time"] {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }
        
        input[type="text"]:focus, input[type="time"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .time-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .time-group {
            position: relative;
        }
        
        .time-calculated {
            background: #e8f5e8 !important;
            border-color: #27ae60 !important;
        }
        
        .time-manual {
            background: #fff3cd !important;
            border-color: #ffc107 !important;
        }
        
        .time-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #27ae60;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .time-indicator.manual {
            background: #ffc107;
        }
        
        .suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .suggestion-item {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }
        
        .suggestion-item:hover {
            background-color: #f8f9fa;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            margin: 10px 0;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        .info-panel {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .info-panel h3 {
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .info-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .info-label {
            font-weight: 600;
        }
        
        .info-value {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .time-info-panel {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 15px;
        }
        
        .time-info-panel h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
            text-align: center;
        }
        
        .time-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .time-display:last-child {
            margin-bottom: 0;
        }
        
        .time-label {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .time-value {
            font-size: 1.3rem;
            font-weight: 700;
        }
        
        #map {
            height: 700px;
            width: 100%;
        }
        
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .error-message {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        .success-message {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        .coords-display {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #3498db;
        }
        
        .coords-display strong {
            color: #2c3e50;
        }
        
        .time-helper {
            font-size: 0.85rem;
            color: #6c757d;
            margin-top: 5px;
            font-style: italic;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .controls {
                border-right: none;
                border-bottom: 1px solid #e9ecef;
            }
            
            #map {
                height: 500px;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .controls {
                padding: 20px;
            }
            
            .container {
                border-radius: 10px;
            }
            
            .time-row {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è Free Open-Source Map Solution</h1>
            <p>Complete mapping solution with time calculation using OpenStreetMap & free APIs</p>
        </div>
        
        <div class="main-content">
            <div class="controls">
                <div class="form-group">
                    <label for="pickup">üìç Pickup Address</label>
                    <div class="input-container">
                        <input type="text" id="pickup" placeholder="Enter pickup address...">
                        <div id="pickup-suggestions" class="suggestions" style="display: none;"></div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="drop">üìç Drop Address</label>
                    <div class="input-container">
                        <input type="text" id="drop" placeholder="Enter drop address...">
                        <div id="drop-suggestions" class="suggestions" style="display: none;"></div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>‚è∞ Time Selection (24H Format)</label>
                    <div class="time-row">
                        <div class="time-group">
                            <label for="pickup-time">Pickup Time</label>
                            <input type="time" id="pickup-time" placeholder="HH:MM">
                            <div id="pickup-time-indicator" class="time-indicator manual" style="display: none;">M</div>
                        </div>
                        <div class="time-group">
                            <label for="drop-time">Drop Time</label>
                            <input type="time" id="drop-time" placeholder="HH:MM">
                            <div id="drop-time-indicator" class="time-indicator" style="display: none;">C</div>
                        </div>
                    </div>
                    <div class="time-helper">
                        Enter either pickup or drop time - the other will be calculated automatically based on route duration
                    </div>
                </div>
                
                <button class="btn" onclick="findRoute()">üöó Find Route & Calculate Times</button>
                <button class="btn btn-secondary" onclick="reverseGeocode()">üîÑ Get Address from Click</button>
                <button class="btn btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
                
                <div id="coords-pickup" class="coords-display" style="display: none;">
                    <strong>Pickup Coordinates:</strong><br>
                    <span id="pickup-coords"></span>
                </div>
                
                <div id="coords-drop" class="coords-display" style="display: none;">
                    <strong>Drop Coordinates:</strong><br>
                    <span id="drop-coords"></span>
                </div>
                
                <div id="route-info" class="info-panel" style="display: none;">
                    <h3>üìä Route Information</h3>
                    <div class="info-item">
                        <span class="info-label">Distance:</span>
                        <span class="info-value" id="distance">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Duration:</span>
                        <span class="info-value" id="duration">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Route Type:</span>
                        <span class="info-value">Driving</span>
                    </div>
                </div>
                
                <div id="time-info" class="time-info-panel" style="display: none;">
                    <h3>‚è∞ Time Calculation</h3>
                    <div class="time-display">
                        <span class="time-label">üü¢ Pickup Time:</span>
                        <span class="time-value" id="calculated-pickup-time">--:--</span>
                    </div>
                    <div class="time-display">
                        <span class="time-label">üî¥ Drop Time:</span>
                        <span class="time-value" id="calculated-drop-time">--:--</span>
                    </div>
                </div>
                
                <div id="error-message" class="error-message" style="display: none;"></div>
                <div id="success-message" class="success-message" style="display: none;"></div>
            </div>
            
            <div id="map"></div>
        </div>
    </div>
    
    <!-- Leaflet JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        // Global variables
        let map;
        let pickupMarker;
        let dropMarker;
        let routeControl;
        let pickupCoords = null;
        let dropCoords = null;
        let reverseGeocodeMode = false;
        let routeDurationMinutes = 0;
        let lastManualTimeField = null; // Track which time field was manually entered
        
        // Initialize map
        function initMap() {
            map = L.map('map').setView([40.7128, -74.0060], 13); // Default to NYC
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            // Add click event for reverse geocoding
            map.on('click', function(e) {
                if (reverseGeocodeMode) {
                    reverseGeocodeFromClick(e.latlng.lat, e.latlng.lng);
                    reverseGeocodeMode = false;
                    document.querySelector('.btn-secondary').innerHTML = 'üîÑ Get Address from Click';
                }
            });
        }
        
        // Time utility functions
        function timeToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }
        
        function minutesToTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
        }
        
        function addMinutesToTime(timeString, minutesToAdd) {
            const totalMinutes = timeToMinutes(timeString) + minutesToAdd;
            // Handle day overflow
            const adjustedMinutes = totalMinutes % (24 * 60);
            return minutesToTime(adjustedMinutes < 0 ? adjustedMinutes + (24 * 60) : adjustedMinutes);
        }
        
        function subtractMinutesFromTime(timeString, minutesToSubtract) {
            const totalMinutes = timeToMinutes(timeString) - minutesToSubtract;
            // Handle day underflow
            const adjustedMinutes = totalMinutes < 0 ? totalMinutes + (24 * 60) : totalMinutes;
            return minutesToTime(adjustedMinutes);
        }
        
        // Calculate and update times
        function calculateTimes() {
            const pickupTimeInput = document.getElementById('pickup-time');
            const dropTimeInput = document.getElementById('drop-time');
            const pickupIndicator = document.getElementById('pickup-time-indicator');
            const dropIndicator = document.getElementById('drop-time-indicator');
            
            if (routeDurationMinutes === 0) return;
            
            // Clear previous styling and indicators
            pickupTimeInput.classList.remove('time-calculated', 'time-manual');
            dropTimeInput.classList.remove('time-calculated', 'time-manual');
            pickupIndicator.style.display = 'none';
            dropIndicator.style.display = 'none';
            
            if (pickupTimeInput.value && !dropTimeInput.value) {
                // Calculate drop time from pickup time
                const calculatedDropTime = addMinutesToTime(pickupTimeInput.value, routeDurationMinutes);
                dropTimeInput.value = calculatedDropTime;
                
                // Update styling
                pickupTimeInput.classList.add('time-manual');
                dropTimeInput.classList.add('time-calculated');
                pickupIndicator.style.display = 'block';
                pickupIndicator.className = 'time-indicator manual';
                dropIndicator.style.display = 'block';
                dropIndicator.className = 'time-indicator';
                
                lastManualTimeField = 'pickup';
                showSuccess(`Drop time calculated: ${calculatedDropTime} (${routeDurationMinutes} minutes journey)`);
                
            } else if (dropTimeInput.value && !pickupTimeInput.value) {
                // Calculate pickup time from drop time
                const calculatedPickupTime = subtractMinutesFromTime(dropTimeInput.value, routeDurationMinutes);
                pickupTimeInput.value = calculatedPickupTime;
                
                // Update styling
                dropTimeInput.classList.add('time-manual');
                pickupTimeInput.classList.add('time-calculated');
                dropIndicator.style.display = 'block';
                dropIndicator.className = 'time-indicator manual';
                pickupIndicator.style.display = 'block';
                pickupIndicator.className = 'time-indicator';
                
                lastManualTimeField = 'drop';
                showSuccess(`Pickup time calculated: ${calculatedPickupTime} (${routeDurationMinutes} minutes before drop)`);
                
            } else if (pickupTimeInput.value && dropTimeInput.value) {
                // Both times entered - update based on last manual entry
                if (lastManualTimeField === 'pickup') {
                    const calculatedDropTime = addMinutesToTime(pickupTimeInput.value, routeDurationMinutes);
                    dropTimeInput.value = calculatedDropTime;
                    
                    pickupTimeInput.classList.add('time-manual');
                    dropTimeInput.classList.add('time-calculated');
                    pickupIndicator.style.display = 'block';
                    pickupIndicator.className = 'time-indicator manual';
                    dropIndicator.style.display = 'block';
                    dropIndicator.className = 'time-indicator';
                    
                } else {
                    const calculatedPickupTime = subtractMinutesFromTime(dropTimeInput.value, routeDurationMinutes);
                    pickupTimeInput.value = calculatedPickupTime;
                    
                    dropTimeInput.classList.add('time-manual');
                    pickupTimeInput.classList.add('time-calculated');
                    dropIndicator.style.display = 'block';
                    dropIndicator.className = 'time-indicator manual';
                    pickupIndicator.style.display = 'block';
                    pickupIndicator.className = 'time-indicator';
                }
            }
            
            // Update time info panel
            updateTimeInfoPanel();
        }
        
        // Update time info panel
        function updateTimeInfoPanel() {
            const pickupTime = document.getElementById('pickup-time').value;
            const dropTime = document.getElementById('drop-time').value;
            
            if (pickupTime && dropTime) {
                document.getElementById('calculated-pickup-time').textContent = pickupTime;
                document.getElementById('calculated-drop-time').textContent = dropTime;
                document.getElementById('time-info').style.display = 'block';
            } else {
                document.getElementById('time-info').style.display = 'none';
            }
        }
        
        // Debounce function for API calls
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Geocoding function
        async function geocode(address) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`
                );
                const data = await response.json();
                
                if (data && data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lng: parseFloat(data[0].lon),
                        display_name: data[0].display_name
                    };
                }
                return null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }
        
        // Reverse geocoding function
        async function reverseGeocode(lat, lng) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1`
                );
                const data = await response.json();
                
                if (data && data.display_name) {
                    return data.display_name;
                }
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            } catch (error) {
                console.error('Reverse geocoding error:', error);
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
        }
        
        // Autocomplete function
        async function getAddressSuggestions(query) {
            if (query.length < 3) return [];
            
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`
                );
                const data = await response.json();
                
                return data.map(item => ({
                    display_name: item.display_name,
                    lat: parseFloat(item.lat),
                    lng: parseFloat(item.lon)
                }));
            } catch (error) {
                console.error('Autocomplete error:', error);
                return [];
            }
        }
        
        // Show suggestions
        async function showSuggestions(inputId, query) {
            const suggestions = await getAddressSuggestions(query);
            const suggestionsDiv = document.getElementById(`${inputId}-suggestions`);
            
            if (suggestions.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            suggestionsDiv.innerHTML = '';
            suggestions.forEach(suggestion => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.textContent = suggestion.display_name;
                div.onclick = () => {
                    document.getElementById(inputId).value = suggestion.display_name;
                    suggestionsDiv.style.display = 'none';
                    
                    // Update coordinates
                    if (inputId === 'pickup') {
                        pickupCoords = { lat: suggestion.lat, lng: suggestion.lng };
                        updateCoordinatesDisplay('pickup', suggestion.lat, suggestion.lng);
                        addPickupMarker(suggestion.lat, suggestion.lng);
                    } else {
                        dropCoords = { lat: suggestion.lat, lng: suggestion.lng };
                        updateCoordinatesDisplay('drop', suggestion.lat, suggestion.lng);
                        addDropMarker(suggestion.lat, suggestion.lng);
                    }
                };
                suggestionsDiv.appendChild(div);
            });
            
            suggestionsDiv.style.display = 'block';
        }
        
        // Add pickup marker
        function addPickupMarker(lat, lng) {
            if (pickupMarker) {
                map.removeLayer(pickupMarker);
            }
            
            pickupMarker = L.marker([lat, lng], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            pickupMarker.bindPopup("üìç Pickup Location").openPopup();
            map.setView([lat, lng], 13);
        }
        
        // Add drop marker
        function addDropMarker(lat, lng) {
            if (dropMarker) {
                map.removeLayer(dropMarker);
            }
            
            dropMarker = L.marker([lat, lng], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            dropMarker.bindPopup("üìç Drop Location").openPopup();
        }
        
        // Update coordinates display
        function updateCoordinatesDisplay(type, lat, lng) {
            const coordsDiv = document.getElementById(`coords-${type}`);
            const coordsSpan = document.getElementById(`${type}-coords`);
            
            coordsSpan.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            coordsDiv.style.display = 'block';
        }
        
        // Find route using OSRM
        async function findRoute() {
            if (!pickupCoords || !dropCoords) {
                showError('Please set both pickup and drop locations first.');
                return;
            }
            
            try {
                document.body.classList.add('loading');
                
                const response = await fetch(
                    `https://router.project-osrm.org/route/v1/driving/${pickupCoords.lng},${pickupCoords.lat};${dropCoords.lng},${dropCoords.lat}?overview=full&geometries=geojson`
                );
                
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    
                    // Remove existing route
                    if (routeControl) {
                        map.removeLayer(routeControl);
                    }
                    
                    // Add new route
                    routeControl = L.geoJSON(route.geometry, {
                        style: {
                            color: '#3498db',
                            weight: 5,
                            opacity: 0.8
                        }
                    }).addTo(map);
                    
                    // Fit map to route
                    const group = new L.featureGroup([pickupMarker, dropMarker, routeControl]);
                    map.fitBounds(group.getBounds().pad(0.1));
                    
                    // Update info panel
                    const distance = (route.distance / 1609.34).toFixed(2); // Convert to miles
                    const duration = Math.round(route.duration / 60); // Convert to minutes
                    routeDurationMinutes = duration; // Store for time calculations
                    
                    document.getElementById('distance').textContent = `${distance} miles`;
                    document.getElementById('duration').textContent = `${duration} minutes`;
                    document.getElementById('route-info').style.display = 'block';
                    
                    // Calculate times if any time is entered
                    calculateTimes();
                    
                    hideError();
                    showSuccess(`Route found successfully! Distance: ${distance} miles, Duration: ${duration} minutes`);
                } else {
                    showError('Could not find a route between these locations.');
                }
            } catch (error) {
                console.error('Routing error:', error);
                showError('Error finding route. Please try again.');
            } finally {
                document.body.classList.remove('loading');
            }
        }
        
        // Reverse geocode from map click
        async function reverseGeocodeFromClick(lat, lng) {
            try {
                const address = await reverseGeocode(lat, lng);
                
                // Determine which field to fill (pickup if empty, otherwise drop)
                const pickupInput = document.getElementById('pickup');
                const dropInput = document.getElementById('drop');
                
                if (!pickupInput.value) {
                    pickupInput.value = address;
                    pickupCoords = { lat, lng };
                    updateCoordinatesDisplay('pickup', lat, lng);
                    addPickupMarker(lat, lng);
                } else {
                    dropInput.value = address;
                    dropCoords = { lat, lng };
                    updateCoordinatesDisplay('drop', lat, lng);
                    addDropMarker(lat, lng);
                }
                
                hideError();
            } catch (error) {
                console.error('Reverse geocoding error:', error);
                showError('Error getting address for this location.');
            }
        }
        
        // Toggle reverse geocode mode
        function reverseGeocode() {
            reverseGeocodeMode = !reverseGeocodeMode;
            const button = document.querySelector('.btn-secondary');
            
            if (reverseGeocodeMode) {
                button.innerHTML = 'üìç Click on Map to Get Address';
                button.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                showError('Click anywhere on the map to get the address for that location.');
            } else {
                button.innerHTML = 'üîÑ Get Address from Click';
                button.style.background = 'linear-gradient(135deg, #95a5a6, #7f8c8d)';
                hideError();
            }
        }
        
        // Clear all
        function clearAll() {
            // Clear inputs
            document.getElementById('pickup').value = '';
            document.getElementById('drop').value = '';
            document.getElementById('pickup-time').value = '';
            document.getElementById('drop-time').value = '';
            
            // Clear coordinates
            pickupCoords = null;
            dropCoords = null;
            routeDurationMinutes = 0;
            lastManualTimeField = null;
            
            // Hide coordinate displays
            document.getElementById('coords-pickup').style.display = 'none';
            document.getElementById('coords-drop').style.display = 'none';
            
            // Clear time styling and indicators
            const pickupTimeInput = document.getElementById('pickup-time');
            const dropTimeInput = document.getElementById('drop-time');
            pickupTimeInput.classList.remove('time-calculated', 'time-manual');
            dropTimeInput.classList.remove('time-calculated', 'time-manual');
            document.getElementById('pickup-time-indicator').style.display = 'none';
            document.getElementById('drop-time-indicator').style.display = 'none';
            
            // Clear markers
            if (pickupMarker) {
                map.removeLayer(pickupMarker);
                pickupMarker = null;
            }
            if (dropMarker) {
                map.removeLayer(dropMarker);
                dropMarker = null;
            }
            
            // Clear route
            if (routeControl) {
                map.removeLayer(routeControl);
                routeControl = null;
            }
            
            // Hide panels
            document.getElementById('route-info').style.display = 'none';
            document.getElementById('time-info').style.display = 'none';
            
            // Hide suggestions
            document.getElementById('pickup-suggestions').style.display = 'none';
            document.getElementById('drop-suggestions').style.display = 'none';
            
            // Reset map view
            map.setView([40.7128, -74.0060], 13);
            
            hideError();
            hideSuccess();
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            hideSuccess();
        }
        
        // Hide error message
        function hideError() {
            document.getElementById('error-message').style.display = 'none';
        }
        
        // Show success message
        function showSuccess(message) {
            const successDiv = document.getElementById('success-message');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            hideError();
            
            // Auto-hide success message after 5 seconds
            setTimeout(() => {
                hideSuccess();
            }, 5000);
        }
        
        // Hide success message
        function hideSuccess() {
            document.getElementById('success-message').style.display = 'none';
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            // Pickup input events
            const pickupInput = document.getElementById('pickup');
            const debouncedPickupSuggestions = debounce((query) => showSuggestions('pickup', query), 300);
            
            pickupInput.addEventListener('input', function() {
                if (this.value.length >= 3) {
                    debouncedPickupSuggestions(this.value);
                } else {
                    document.getElementById('pickup-suggestions').style.display = 'none';
                }
            });
            
            pickupInput.addEventListener('blur', function() {
                setTimeout(() => {
                    document.getElementById('pickup-suggestions').style.display = 'none';
                }, 200);
            });
            
            // Drop input events
            const dropInput = document.getElementById('drop');
            const debouncedDropSuggestions = debounce((query) => showSuggestions('drop', query), 300);
            
            dropInput.addEventListener('input', function() {
                if (this.value.length >= 3) {
                    debouncedDropSuggestions(this.value);
                } else {
                    document.getElementById('drop-suggestions').style.display = 'none';
                }
            });
            
            dropInput.addEventListener('blur', function() {
                setTimeout(() => {
                    document.getElementById('drop-suggestions').style.display = 'none';
                }, 200);
            });
            
            // Time input events
            const pickupTimeInput = document.getElementById('pickup-time');
            const dropTimeInput = document.getElementById('drop-time');
            
            pickupTimeInput.addEventListener('change', function() {
                if (this.value) {
                    lastManualTimeField = 'pickup';
                    if (routeDurationMinutes > 0) {
                        calculateTimes();
                    }
                }
            });
            
            dropTimeInput.addEventListener('change', function() {
                if (this.value) {
                    lastManualTimeField = 'drop';
                    if (routeDurationMinutes > 0) {
                        calculateTimes();
                    }
                }
            });
            
            // Enter key support for address inputs
            pickupInput.addEventListener('keypress', async function(e) {
                if (e.key === 'Enter') {
                    const result = await geocode(this.value);
                    if (result) {
                        pickupCoords = { lat: result.lat, lng: result.lng };
                        updateCoordinatesDisplay('pickup', result.lat, result.lng);
                        addPickupMarker(result.lat, result.lng);
                        hideError();
                    } else {
                        showError('Could not find the pickup address.');
                    }
                }
            });
            
            dropInput.addEventListener('keypress', async function(e) {
                if (e.key === 'Enter') {
                    const result = await geocode(this.value);
                    if (result) {
                        dropCoords = { lat: result.lat, lng: result.lng };
                        updateCoordinatesDisplay('drop', result.lat, result.lng);
                        addDropMarker(result.lat, result.lng);
                        hideError();
                    } else {
                        showError('Could not find the drop address.');
                    }
                }
            });
        });
    </script>
</body>
</html>